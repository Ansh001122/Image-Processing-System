import asyncio
import aiohttp
import aiofiles
from PIL import Image
import io
import os
import logging
from typing import List

logger = logging.getLogger(__name__)

class ImageProcessor:
    """Service to handle image downloading and processing"""
   
    def __init__(self):
        self.processed_dir = "processed_images"
        os.makedirs(self.processed_dir, exist_ok=True)
   
    async def process_product_images(self, request_id: str, product_name: str, input_urls: List[str]) -> List[str]:
        """
        Process all images for a single product
       
        Args:
            request_id: Unique request identifier
            product_name: Name of the product
            input_urls: List of input image URLs
           
        Returns:
            List of output image URLs
        """
        output_urls = []
       
        # Create semaphore to limit concurrent downloads
        semaphore = asyncio.Semaphore(5)
       
        tasks = []
        for i, url in enumerate(input_urls):
            task = self.process_single_image(semaphore, request_id, product_name, url, i)
            tasks.append(task)
       
        results = await asyncio.gather(*tasks, return_exceptions=True)
       
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Error processing image: {str(result)}")
                output_urls.append("")  # Empty string for failed processing
            else:
                output_urls.append(result)
       
        return output_urls
   
    async def process_single_image(self, semaphore: asyncio.Semaphore, request_id: str,
                                 product_name: str, image_url: str, index: int) -> str:
        """
        Process a single image: download, compress, and save
       
        Args:
            semaphore: Semaphore for limiting concurrent operations
            request_id: Unique request identifier
            product_name: Name of the product
            image_url: URL of the input image
            index: Index of the image in the product's image list
           
        Returns:
            URL or path of the processed image
        """
        async with semaphore:
            try:
                # Download image
                async with aiohttp.ClientSession() as session:
                    async with session.get(image_url, timeout=30) as response:
                        if response.status != 200:
                            raise Exception(f"Failed to download image: {response.status}")
                       
                        image_data = await response.read()
               
                # Process image (compress by 50%)
                image = Image.open(io.BytesIO(image_data))
               
                # Convert to RGB if necessary
                if image.mode in ('RGBA', 'P'):
                    image = image.convert('RGB')
               
                # Compress image (reduce quality to 50%)
                output_buffer = io.BytesIO()
                image.save(output_buffer, format='JPEG', quality=50, optimize=True)
                compressed_data = output_buffer.getvalue()
               
                # Generate output filename
                safe_product_name = "".join(c for c in product_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
                output_filename = f"{request_id}_{safe_product_name}_{index}.jpg"
                output_path = os.path.join(self.processed_dir, output_filename)
               
                # Save compressed image
                async with aiofiles.open(output_path, 'wb') as f:
                    await f.write(compressed_data)
               
                # Return the path or URL (in production, this would be a public URL)
                return f"/processed_images/{output_filename}"
               
            except Exception as e:
                logger.error(f"Error processing image {image_url}: {str(e)}")
                raise